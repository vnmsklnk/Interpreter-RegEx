{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Interpreter-RegEx is a tool for elementary programming language created for processing regular expressions. There are Quadtree and Matrix operations libraries also. Interpreter has user-friendly console interface; Matrix operations and Quadtree libraries can be used only by developers.","title":"About"},{"location":"#about","text":"Interpreter-RegEx is a tool for elementary programming language created for processing regular expressions. There are Quadtree and Matrix operations libraries also. Interpreter has user-friendly console interface; Matrix operations and Quadtree libraries can be used only by developers.","title":"About"},{"location":"Installation/","text":"Installation You can install the package with dotnet by following this steps: Add a source and PAT in your nuget.config file: dotnet nuget add source --username <YOUR_USERNAME> --password <PAT> --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/IvanMoskalenko/index.json\" Install the package by using this command: dotnet add PROJECT package Interpreter-RegEx --version <version>","title":"Installation"},{"location":"Installation/#installation","text":"You can install the package with dotnet by following this steps: Add a source and PAT in your nuget.config file: dotnet nuget add source --username <YOUR_USERNAME> --password <PAT> --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/IvanMoskalenko/index.json\" Install the package by using this command: dotnet add PROJECT package Interpreter-RegEx --version <version>","title":"Installation"},{"location":"Interpreter/","text":"Interpreter Developers To interpret your code, at first you need to create an abstract syntax tree by using Interpreter.parseProgramToAST <string> Then you can run the Interpreter.run <AST> function that returns two dictionaries. The first contains values of all variables in Interpreter.VType format, the second has only one key - \"print\" with interpretation result in string format. You can also get a dot file which contains an abstract syntax tree by using AstToDot.astToDot <output file path> <AST> Another functions processExpression (vDict: Dictionary<AST.VName, VType>) (expression: AST.Expr) - return a result of a given expression in VType format. processStmt (vDict: Dictionary<AST.VName, VType>) (pDict: Dictionary<string, string>) (stmt: AST.Stmt) - gets an expression from specified statement and sets it's value to the dictionaries with variable as a key. Example let program = \" let [a] = (x|a)a let [b] = a* let [c] = isAcceptable \\\" a \\\" [a]&[b] let [d] = isAcceptable \\\" 1 \\\" (1*)&(1?) let [e] = findAll \" byx \" a|y print [c] print [d] print [e]\" let ast = Interpreter . parseProgramToAST program let _ , pDict = Interpreter . run ast printfn \"%A\" pDict .[ \"print\" ] Given code prints False True [(1, 2)] into console. Users There are four console commands in Interpreter-RegEx. --inputfile <file path> - the path to the file with code. --inputstring <string> - the string with code. --compute - returns the result of interpretation of the code --todot <file path> - saves .dot file with abstract syntax tree to the path specified.","title":"Interpreter"},{"location":"Interpreter/#interpreter","text":"","title":"Interpreter"},{"location":"Interpreter/#developers","text":"To interpret your code, at first you need to create an abstract syntax tree by using Interpreter.parseProgramToAST <string> Then you can run the Interpreter.run <AST> function that returns two dictionaries. The first contains values of all variables in Interpreter.VType format, the second has only one key - \"print\" with interpretation result in string format. You can also get a dot file which contains an abstract syntax tree by using AstToDot.astToDot <output file path> <AST>","title":"Developers"},{"location":"Interpreter/#another-functions","text":"processExpression (vDict: Dictionary<AST.VName, VType>) (expression: AST.Expr) - return a result of a given expression in VType format. processStmt (vDict: Dictionary<AST.VName, VType>) (pDict: Dictionary<string, string>) (stmt: AST.Stmt) - gets an expression from specified statement and sets it's value to the dictionaries with variable as a key.","title":"Another functions"},{"location":"Interpreter/#example","text":"let program = \" let [a] = (x|a)a let [b] = a* let [c] = isAcceptable \\\" a \\\" [a]&[b] let [d] = isAcceptable \\\" 1 \\\" (1*)&(1?) let [e] = findAll \" byx \" a|y print [c] print [d] print [e]\" let ast = Interpreter . parseProgramToAST program let _ , pDict = Interpreter . run ast printfn \"%A\" pDict .[ \"print\" ] Given code prints False True [(1, 2)] into console.","title":"Example"},{"location":"Interpreter/#users","text":"There are four console commands in Interpreter-RegEx. --inputfile <file path> - the path to the file with code. --inputstring <string> - the string with code. --compute - returns the result of interpretation of the code --todot <file path> - saves .dot file with abstract syntax tree to the path specified.","title":"Users"},{"location":"Language/","text":"Language guide Interpreter-RegEx uses simple programming language to define regular expressions. Grammar Each regular expression is defined as variable which can be used in other expressions. Typical program consists of statements with expressions and variables' names associated with them. Statements There are three types of statements supported in the language: print [<vname>] let [<vname>] = <expression> printToDot [<vname>: RegExp] <string> print prints the regular expression corresponding to the given variable, let defines a variable and printToDot outputs regular expression in .dot format. <vname> starts with a Latin character, which can be followed by numbers or other letters. <expression> consists of Latin letters, digits, characters '-' '.' '/' '+' '~' ';' and other variables. As operators characters '(' ')' '*' '|' '?' '&' can be used. Regex type RSmb of <char> RVar of <VName> Alt of <Regex * Regex> Seq of <Regex * Regex> Opt of <Regex> Star of <Regex> Intersect of <Regex * Regex> RVar case allows variables to be used inside regular expressions. Expressions RegExp of <Regex> FindAll of <string * Regex> IsAcceptable of <string * Regex> FindAll searches for all substrings satisfying the specified regular expression, IsAcceptable checks whether the string belongs to the specified expression. Operators Available operators in Interpreter-RegEx: * - Kleene star | - alternation ? - repeat 0 or 1 times & - intersect ( , ) - brackets for grouping Code example let [a] = (x|a)a let [b] = a* let [c] = isAcceptable \"a\" [a]&[b] let [d] = isAcceptable \"1\" (1*)&(1?) let [e] = findAll \"byx\" a|y print [c] # output: False print [d] # output: True print [e] # output: [(1, 2)]","title":"Language guide"},{"location":"Language/#language-guide","text":"Interpreter-RegEx uses simple programming language to define regular expressions.","title":"Language guide"},{"location":"Language/#grammar","text":"Each regular expression is defined as variable which can be used in other expressions. Typical program consists of statements with expressions and variables' names associated with them.","title":"Grammar"},{"location":"Language/#statements","text":"There are three types of statements supported in the language: print [<vname>] let [<vname>] = <expression> printToDot [<vname>: RegExp] <string> print prints the regular expression corresponding to the given variable, let defines a variable and printToDot outputs regular expression in .dot format. <vname> starts with a Latin character, which can be followed by numbers or other letters. <expression> consists of Latin letters, digits, characters '-' '.' '/' '+' '~' ';' and other variables. As operators characters '(' ')' '*' '|' '?' '&' can be used.","title":"Statements"},{"location":"Language/#regex-type","text":"RSmb of <char> RVar of <VName> Alt of <Regex * Regex> Seq of <Regex * Regex> Opt of <Regex> Star of <Regex> Intersect of <Regex * Regex> RVar case allows variables to be used inside regular expressions.","title":"Regex type"},{"location":"Language/#expressions","text":"RegExp of <Regex> FindAll of <string * Regex> IsAcceptable of <string * Regex> FindAll searches for all substrings satisfying the specified regular expression, IsAcceptable checks whether the string belongs to the specified expression.","title":"Expressions"},{"location":"Language/#operators","text":"Available operators in Interpreter-RegEx: * - Kleene star | - alternation ? - repeat 0 or 1 times & - intersect ( , ) - brackets for grouping","title":"Operators"},{"location":"Language/#code-example","text":"let [a] = (x|a)a let [b] = a* let [c] = isAcceptable \"a\" [a]&[b] let [d] = isAcceptable \"1\" (1*)&(1?) let [e] = findAll \"byx\" a|y print [c] # output: False print [d] # output: True print [e] # output: [(1, 2)]","title":"Code example"},{"location":"MatrixLib/","text":"Matrix Library MatrixLib is a quadtrees based library for working with matrices. Type SparseMtx Square sparse matrix implemented on quadtrees using square regions (matrix cells). The size of this matrix is always a power of two, if it is not, it will be rounded to next nearest power of two. Additional matrix cells are considered zero values. Fields val size: int - size of the matrix. val ops: Operators<'a> - basic operators (getZero, equality). val tree: Quadtree<int, 'a> - Quadtree used as storage for matrix values. Matrix Algebra Matrix Algebra is a module with algebraic operations on matrices. sum (semiring: Semiring<_>) (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - adds two matrices. multiply (semiring: Semiring<_>) (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - multiplies two matrices. multiplyParallel (semiring: Semiring<_>) (depth: int) (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - multiplies two matrices concurrently. Number of threads = 4^depth. kroneckerProduct (semiring: Semiring<_>) (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - calculates Kronecker product of two matrices. closure (semiring: Semiring<_>) (matrix: SparseMtx<_>) - transitive closure of two matrices. SparseMtx functions SparseMtx is a module with standard functions on matrices. init (size: int) (operators: Operators<'a>) (initializer: int -> int -> 'a) - creates new matrix with initializer given. iteri (iterator: int -> int -> 'a -> unit) (matrix: SparseMtx<_>) - applies the given func to each element of matrix. The integers passed to the function indicates the coordinates of element. iter (iterator: 'a -> unit) (matrix: SparseMtx<_>) - applies the given func to each element of matrix. mapi (outerTypeOps: Operators<'b>) (mapping: int -> int -> 'a -> 'b) (matrix: SparseMtx<'a>) - builds a new matrix whose elements are the results of applying the given function to each of the elements of the matrix. The integers passed to the function indicates the coordinates of element being transformed. map (outerTypeOps: Operators<'b>) (mapping: 'a -> 'b) (matrix: SparseMtx<'a>) - builds a new matrix whose elements are the results of applying the given function to each of the elements of the matrix. toArray2D (matrix: SparseMtx<_>) - transforms matrix to Array2D. doubleSize (matrix: SparseMtx<_>) - returns matrix of 2X size. isEqual (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - equality of two matrices. SparseArray2D SparseArray2D is a module with operations on matrices based on Array2D. getBounds (matrix: 'a [,]) - returns struct with dimensions of Array2D. genIntMatrix (rows: int, cols: int) (sparsity: float) - generates matrix with sparsity specified. add (sr: Semiring<'a>) (matrix1: 'a [,]) (matrix2: 'a [,]) - adds two matrices. multiply (sr: Semiring<'a>) (matrix1: 'a [,]) (matrix2: 'a [,]) - multiplies two matrices. kroneckerProduct (sr: Semiring<'a>) (matrix1: 'a [,]) (matrix2: 'a [,]) - calculates Kronecker product of two matrices. closure (sr: Semiring<'a>) (predicateFunc: 'a -> bool) (matrix: 'a [,]) - transitive closure of two matrices with predicate function specified.","title":"Matrix Library"},{"location":"MatrixLib/#matrix-library","text":"MatrixLib is a quadtrees based library for working with matrices.","title":"Matrix Library"},{"location":"MatrixLib/#type-sparsemtx","text":"Square sparse matrix implemented on quadtrees using square regions (matrix cells). The size of this matrix is always a power of two, if it is not, it will be rounded to next nearest power of two. Additional matrix cells are considered zero values.","title":"Type SparseMtx"},{"location":"MatrixLib/#fields","text":"val size: int - size of the matrix. val ops: Operators<'a> - basic operators (getZero, equality). val tree: Quadtree<int, 'a> - Quadtree used as storage for matrix values.","title":"Fields"},{"location":"MatrixLib/#matrix-algebra","text":"Matrix Algebra is a module with algebraic operations on matrices. sum (semiring: Semiring<_>) (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - adds two matrices. multiply (semiring: Semiring<_>) (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - multiplies two matrices. multiplyParallel (semiring: Semiring<_>) (depth: int) (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - multiplies two matrices concurrently. Number of threads = 4^depth. kroneckerProduct (semiring: Semiring<_>) (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - calculates Kronecker product of two matrices. closure (semiring: Semiring<_>) (matrix: SparseMtx<_>) - transitive closure of two matrices.","title":"Matrix Algebra"},{"location":"MatrixLib/#sparsemtx-functions","text":"SparseMtx is a module with standard functions on matrices. init (size: int) (operators: Operators<'a>) (initializer: int -> int -> 'a) - creates new matrix with initializer given. iteri (iterator: int -> int -> 'a -> unit) (matrix: SparseMtx<_>) - applies the given func to each element of matrix. The integers passed to the function indicates the coordinates of element. iter (iterator: 'a -> unit) (matrix: SparseMtx<_>) - applies the given func to each element of matrix. mapi (outerTypeOps: Operators<'b>) (mapping: int -> int -> 'a -> 'b) (matrix: SparseMtx<'a>) - builds a new matrix whose elements are the results of applying the given function to each of the elements of the matrix. The integers passed to the function indicates the coordinates of element being transformed. map (outerTypeOps: Operators<'b>) (mapping: 'a -> 'b) (matrix: SparseMtx<'a>) - builds a new matrix whose elements are the results of applying the given function to each of the elements of the matrix. toArray2D (matrix: SparseMtx<_>) - transforms matrix to Array2D. doubleSize (matrix: SparseMtx<_>) - returns matrix of 2X size. isEqual (matrix1: SparseMtx<_>) (matrix2: SparseMtx<_>) - equality of two matrices.","title":"SparseMtx functions"},{"location":"MatrixLib/#sparsearray2d","text":"SparseArray2D is a module with operations on matrices based on Array2D. getBounds (matrix: 'a [,]) - returns struct with dimensions of Array2D. genIntMatrix (rows: int, cols: int) (sparsity: float) - generates matrix with sparsity specified. add (sr: Semiring<'a>) (matrix1: 'a [,]) (matrix2: 'a [,]) - adds two matrices. multiply (sr: Semiring<'a>) (matrix1: 'a [,]) (matrix2: 'a [,]) - multiplies two matrices. kroneckerProduct (sr: Semiring<'a>) (matrix1: 'a [,]) (matrix2: 'a [,]) - calculates Kronecker product of two matrices. closure (sr: Semiring<'a>) (predicateFunc: 'a -> bool) (matrix: 'a [,]) - transitive closure of two matrices with predicate function specified.","title":"SparseArray2D"},{"location":"Quadtrees/","text":"Quadtrees Quadtrees is a library of operations on quadtrees which is used in Matrix Library. Type Quadtree Generic implementation of Point-Region Quadtree Data Structure where: Region is an abstraction (immutable) of two-dimensional space; Region may have integer, float or custom coordinates; (implements IRegion< 'coordinateType > interface) Content represents quad node data which could be: Emtpy (no data inside); Leaf (coordinates point (point in 2D space) associated with value of type 'a); Nodes (sub-nodes inside the quadtree); Content of quadtree is mutable and could be changed explicitly or by inserting new values Fields Region: IRegion<'c> - abstraction (immutable) of two-dimensional space. Content: QuadNode<'c, 't> - represents quad node data, which could be Empty, Leaf or Nodes. QuadtreeUtils QuadtreeUtils is a module with useful utilities for working with quadtrees. getTreeBounds (tree: Quadtree<'a, 'b> - returns quadtree region size X, Y. emptyTree (region: IRegion<_>) - returns empty quadtree with specified region. makeTree (region: IRegion<_>) (content: QuadNode<'a, 'b>) - construct quadtree from Quadnode. allNodesEmpty (nodes: QuadNode<'a,'b> * QuadNode<'c,'d> * QuadNode<'e,'f> * QuadNode<'g,'h>) - checks if all passed subtrees are empty. MutableQT Basic operations for quadtrees. get ((x: 'a) * (y: 'a)) (tree: Quadtree<'a,'b>) - returns option of value at (x, y) coordinates in the quadtree. balanceLeaf (point: ('c * 'c), value: 'a) (parent: Quadtree<'c,'a>) - balance tree containing single leaf; returns balanced subtree. insert (x: 'a, y: 'a) (newValue: 'b) (tree: Quadtree<_,_>) - inserts a point (with associated value) into a quadtree. iter (action: 'a -> unit) (tree: Quadtree<'b,'a>) - applies the given func to each element of tree. iteri (action: 'a -> -> 'a -> 'b -> unit) (tree: Quadtree<'a,'b>) - applies the given func to each element of tree. The numbers passed to the function indicates the coordinates of element. sum (operators: ('a -> bool) * ('a -> 'a -> 'a)) (tree1: Quadtree<'c,'a>) (tree2: Quadtree<'c,'a>) - point-wise sum of elements contained in two quadtrees. toSubregions (region: IRegion<_>) - splits region into 4 subregions. subdivide (dir: Direction) (parentTree: Quadtree<_,_>) - subdivides specified quadtree, if quadtree only consists of one leaf - leaf will be balanced and pushed to correct subregion. Returns subtree in specified direction; throws exception if minimum region reached.","title":"Quadtrees"},{"location":"Quadtrees/#quadtrees","text":"Quadtrees is a library of operations on quadtrees which is used in Matrix Library.","title":"Quadtrees"},{"location":"Quadtrees/#type-quadtree","text":"Generic implementation of Point-Region Quadtree Data Structure where: Region is an abstraction (immutable) of two-dimensional space; Region may have integer, float or custom coordinates; (implements IRegion< 'coordinateType > interface) Content represents quad node data which could be: Emtpy (no data inside); Leaf (coordinates point (point in 2D space) associated with value of type 'a); Nodes (sub-nodes inside the quadtree); Content of quadtree is mutable and could be changed explicitly or by inserting new values","title":"Type Quadtree"},{"location":"Quadtrees/#fields","text":"Region: IRegion<'c> - abstraction (immutable) of two-dimensional space. Content: QuadNode<'c, 't> - represents quad node data, which could be Empty, Leaf or Nodes.","title":"Fields"},{"location":"Quadtrees/#quadtreeutils","text":"QuadtreeUtils is a module with useful utilities for working with quadtrees. getTreeBounds (tree: Quadtree<'a, 'b> - returns quadtree region size X, Y. emptyTree (region: IRegion<_>) - returns empty quadtree with specified region. makeTree (region: IRegion<_>) (content: QuadNode<'a, 'b>) - construct quadtree from Quadnode. allNodesEmpty (nodes: QuadNode<'a,'b> * QuadNode<'c,'d> * QuadNode<'e,'f> * QuadNode<'g,'h>) - checks if all passed subtrees are empty.","title":"QuadtreeUtils"},{"location":"Quadtrees/#mutableqt","text":"Basic operations for quadtrees. get ((x: 'a) * (y: 'a)) (tree: Quadtree<'a,'b>) - returns option of value at (x, y) coordinates in the quadtree. balanceLeaf (point: ('c * 'c), value: 'a) (parent: Quadtree<'c,'a>) - balance tree containing single leaf; returns balanced subtree. insert (x: 'a, y: 'a) (newValue: 'b) (tree: Quadtree<_,_>) - inserts a point (with associated value) into a quadtree. iter (action: 'a -> unit) (tree: Quadtree<'b,'a>) - applies the given func to each element of tree. iteri (action: 'a -> -> 'a -> 'b -> unit) (tree: Quadtree<'a,'b>) - applies the given func to each element of tree. The numbers passed to the function indicates the coordinates of element. sum (operators: ('a -> bool) * ('a -> 'a -> 'a)) (tree1: Quadtree<'c,'a>) (tree2: Quadtree<'c,'a>) - point-wise sum of elements contained in two quadtrees. toSubregions (region: IRegion<_>) - splits region into 4 subregions. subdivide (dir: Direction) (parentTree: Quadtree<_,_>) - subdivides specified quadtree, if quadtree only consists of one leaf - leaf will be balanced and pushed to correct subregion. Returns subtree in specified direction; throws exception if minimum region reached.","title":"MutableQT"},{"location":"Structure/","text":"Github repository structure Interpreter-RegEx \u251c\u2500\u2500 .config - dotnet tools \u251c\u2500\u2500 .github - GitHub Actions setup \u251c\u2500\u2500 docs - documentation files in .md format \u251c\u2500\u2500 src - code of the tool \u2502 \u251c\u2500\u2500 Interpreter - interpreter of regular expressions | \u251c\u2500\u2500 Interpreter.Cli - command interface for Interpreter | \u251c\u2500\u2500 MatrixLib - library of matrix operations based on quadtrees | \u2514\u2500\u2500 Quadtrees - quadtrees library \u251c\u2500\u2500 tests - tests | \u251c\u2500\u2500 Interpreter.UnitTests - tests for Interpreter | \u2514\u2500\u2500 Quadtrees.UnitTests - tests for MatrixLib and Quadtrees \u251c\u2500\u2500 fsharplint.json - linter config \u251c\u2500\u2500 mkdocs.yml - MkDocs config \u2514\u2500\u2500 Interpreter.sln - solution file","title":"Github repository structure"},{"location":"Structure/#github-repository-structure","text":"Interpreter-RegEx \u251c\u2500\u2500 .config - dotnet tools \u251c\u2500\u2500 .github - GitHub Actions setup \u251c\u2500\u2500 docs - documentation files in .md format \u251c\u2500\u2500 src - code of the tool \u2502 \u251c\u2500\u2500 Interpreter - interpreter of regular expressions | \u251c\u2500\u2500 Interpreter.Cli - command interface for Interpreter | \u251c\u2500\u2500 MatrixLib - library of matrix operations based on quadtrees | \u2514\u2500\u2500 Quadtrees - quadtrees library \u251c\u2500\u2500 tests - tests | \u251c\u2500\u2500 Interpreter.UnitTests - tests for Interpreter | \u2514\u2500\u2500 Quadtrees.UnitTests - tests for MatrixLib and Quadtrees \u251c\u2500\u2500 fsharplint.json - linter config \u251c\u2500\u2500 mkdocs.yml - MkDocs config \u2514\u2500\u2500 Interpreter.sln - solution file","title":"Github repository structure"}]}